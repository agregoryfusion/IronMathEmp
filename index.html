<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>Fast Math</title>
<style>
  :root{
    --bg:#0e0f12; --text:#ffffff; --muted:#a8b0bb; --accent:#1e90ff; --accent2:#00bfff; --panel:#161a20; --input:#15181d;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial;text-align:center}
  h1{margin:18px 0 6px;color:var(--accent)}
  #version { color: var(--accent); font-size: 0.5em; margin-top: -6px;}

  /* LOGIN */
  #login-screen{min-height:40vh;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:10px}
  #loginBtn{background:#0078d4;border:none;color:#fff;border-radius:8px;padding:12px 20px;font-size:16px;cursor:pointer}
  #loginBtn:hover{background:#005ea6}
  #loginStatus{color:#ff8a8a;font-size:13px}

  /* EMPEROR SCREEN */
  #emperor-screen{
    display:none;
    min-height:40vh;
    padding-top:40px;
  }
  #playBtn{
    margin-top:20px;
    background:var(--accent);
    padding:14px 24px;
    border:none;
    border-radius:10px;
    color:white;
    font-size:20px;
    cursor:pointer;
  }
  #playBtn:hover{filter:brightness(1.1)}

  /* GAME */
  #game-container{display:none;max-width:900px;margin:0 auto;padding:10px 16px}
  #question{font-size:48px;font-weight:700;margin-top:80px;margin-bottom:30px;min-height:1.2em;transition:transform .05s}
  #timerBar{width:70%;height:30px;background:#20242b;border-radius:15px;margin:30px auto 30px;overflow:hidden;box-shadow:0 0 10px #1e90ff55}
  #timerFill{height:100%;background:linear-gradient(90deg, var(--accent), var(--accent2));width:100%}
  #answer{font-size:32px;padding:10px;border-radius:10px;border:2px solid var(--accent);width:140px;background:var(--input);color:#fff;text-align:center;outline:none;box-shadow:0 0 10px #1e90ff33;margin-bottom:16px}
  #answer:focus{border-color:var(--accent2);box-shadow:0 0 15px #00bfff55}
  #stage-info{margin-top:6px;font-size:18px;color:#c9d2db}

  /* END SCREEN */
  #end-screen{display:none;text-align:center;margin-top:60px;color:#fff}
  #end-screen h3{color:#ff4d4d;font-size:28px;margin:4px 0 10px}
  #end-screen p{margin:6px 0;font-size:18px}
  #end-screen button{background:var(--accent);border:none;color:#fff;padding:10px 20px;font-size:16px;border-radius:8px;margin:10px;cursor:pointer;transition:filter .2s}
  #end-screen button:hover{filter:brightness(1.05)}
  #session-id{color:#99a6b4;font-size:14px}
  #saved-status{color:#7fdca2;font-size:14px}

  /* LEADERBOARD */
  #leaderboardContainer{display:none;margin:40px auto 20px;max-width:800px;text-align:center;opacity:0;transition:opacity .3s}
  #leaderboardContainer.show{opacity:1}
  #leaderboardStatus{color:#cfd6de;font-size:14px}
  #leaderboardContainer table{width:100%;border-collapse:collapse;margin-top:12px}
  #leaderboardContainer th,#leaderboardContainer td{padding:10px;border-bottom:1px solid #2a2f37;text-align:center}
  #leaderboardContainer th{color:var(--accent);font-weight:600;border-bottom:2px solid #1e90ff33}
  #leaderboardContainer td{color:#e6e9ee}
  #leaderboardContainer tr:hover td{background:#1e90ff22}
</style>
</head>
<body>
  <h1>Fusion Fast Math</h1>
  <p id="version">v1.0.25</p>

  <!-- Login -->
  <div id="login-screen">
    <p class="note" style="color:#c9d2db">Please sign in with your Microsoft account to continue.</p>
    <button id="loginBtn">Sign in with Microsoft</button>
    <div id="loginStatus"></div>
  </div>

  <!-- Emperor Screen -->
  <div id="emperor-screen">
    <h2 id="emperorName">The Current Emperor of Multiplication Is: â€”</h2>
    <h3 id="emperorScore">With A Score Of: â€”</h3>
    <button id="playBtn">Play</button>
  </div>

  <!-- Game -->
  <div id="game-container">
    <div id="question"></div>
    <div id="timerBar"><div id="timerFill"></div></div>
    <input id="answer" type="text" autocomplete="off" inputmode="numeric" placeholder="?" />
    <div id="stage-info"></div>
  </div>

  <!-- End Screen -->
  <div id="end-screen">
    <h3>Game Over</h3>
    <p id="end-questions">Questions answered: â€”</p>
    <p id="end-penalty">Total penalty time: â€” s</p>
    <p id="end-total">Total time: â€” s (<span id="end-with-penalty">â€”</span> s with penalties)</p>
    <p id="end-avg">Avg time/question: â€” s (<span id="end-avg-with-penalty">â€”</span> s with penalties)</p>
    <p id="saved-status"></p>
    <button id="restartBtn">Restart</button>
  </div>

  <!-- Firebase + Game Logic -->
  <script type="module">

    /* =========================== Firebase =========================== */

    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-app.js";
    import {
      getAuth, OAuthProvider, signInWithPopup,
      setPersistence, browserLocalPersistence, onAuthStateChanged
    } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-auth.js";
    import {
      getFirestore, collection, doc, setDoc, addDoc,
      getDocs, query, orderBy, limit
    } from "https://www.gstatic.com/firebasejs/11.0.0/firebase-firestore.js";

    /* =========================== Config =========================== */

    const firebaseConfig = {
      apiKey: "AIzaSyBUaOrUckCuTrc9MHB9jCF4TUsx-hWFC7g",
      authDomain: "ironmath-1263b.firebaseapp.com",
      projectId: "ironmath-1263b",
      storageBucket: "ironmath-1263b.firebasestorage.app",
      messagingSenderId: "729878130193",
      appId: "1:729878130193:web:f4d447b552e4f955f80bb0",
      measurementId: "G-0VCM7C1HPC"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    const provider = new OAuthProvider("microsoft.com");
    await setPersistence(auth, browserLocalPersistence);

    /* =========================== DOM =========================== */

    const loginScreen = document.getElementById("login-screen");
    const emperorScreen = document.getElementById("emperor-screen");
    const playBtn = document.getElementById("playBtn");
    const emperorName = document.getElementById("emperorName");
    const emperorScore = document.getElementById("emperorScore");

    const gameContainer = document.getElementById("game-container");
    const endScreen = document.getElementById("end-screen");

    /* ========== Leaderboard Cache Setup ========== */

    let cachedLeaderboardData = null;
    let lastLeaderboardFetchTime = 0;
    const CACHE_TIME = 60000; // 60 sec

    async function loadLeaderboardAtStartup() {
      const now = Date.now();
      if (cachedLeaderboardData && (now - lastLeaderboardFetchTime) < CACHE_TIME) return;

      const qy = query(
        collection(db, "leaderboard"),
        orderBy("questionsAnswered", "desc"),
        orderBy("totalTime", "asc"),
        limit(500)
      );

      const snap = await getDocs(qy);

      const grouped = {};
      snap.forEach(docSnap => {
        const d = docSnap.data();
        const key = (d.playerName || "").trim().toLowerCase();
        if (!grouped[key]) grouped[key] = [];
        grouped[key].push(d);
      });

      const best = Object.values(grouped).map(list =>
        list.sort((a, b) => {
          if (b.questionsAnswered === a.questionsAnswered)
            return a.totalTime - b.totalTime;
          return b.questionsAnswered - a.questionsAnswered;
        })[0]
      );

      best.sort((a, b) => {
        if (b.questionsAnswered === a.questionsAnswered)
          return a.totalTime - b.totalTime;
        return b.questionsAnswered - a.questionsAnswered;
      });
      // ðŸ”¥ New line: keep only students for Emperor logic
      cachedLeaderboardData = best.filter(d => d.isStudent === true);
      lastLeaderboardFetchTime = now;
    }

    function showEmperor() {
      const top = cachedLeaderboardData?.[0];

      if (top) {
        emperorName.textContent =
          `The Current Emperor of Multiplication Is: ${top.playerName}`;
        emperorScore.textContent =
          `With A Score Of: ${top.questionsAnswered}`;
      }

      emperorScreen.style.display = "block";
    }

    /* ====================== Authentication Flow ====================== */

    let playerName = "Player";

    function parseEmailToName(email){
      if(!email) return "Player";
      const local = email.split("@")[0];
      const parts = local.split(/[._-]+/).filter(Boolean);
      if(parts.length >= 2) return parts.map(cap).join(" ");
      return cap(local);
    }
    const cap = s => s ? s.charAt(0).toUpperCase() + s.slice(1) : s;

    onAuthStateChanged(auth, async (user) => {
      if (user) {
        playerName = user.displayName || parseEmailToName(user.email);

        loginScreen.style.display = "none";

        await loadLeaderboardAtStartup();
        showEmperor();
      } else {
        emperorScreen.style.display = "none";
        gameContainer.style.display = "none";
        endScreen.style.display = "none";
        loginScreen.style.display = "flex";
      }
    });

    document.getElementById("loginBtn").addEventListener("click", async ()=>{
      try {
        const result = await signInWithPopup(auth, provider);
        const u = result.user;
        playerName = u.displayName || parseEmailToName(u.email);

        loginScreen.style.display = "none";

        await loadLeaderboardAtStartup();
        showEmperor();
      } catch(e){
        loginStatus.textContent = "Sign-in failed: " + (e?.message || e);
      }
    });

    /* ====================== Game Logic ====================== */

    playBtn.addEventListener("click", () => {
      emperorScreen.style.display = "none";
      gameContainer.style.display = "block";
      startGame();
    });

    document.getElementById("restartBtn").addEventListener("click", () => {
      endScreen.style.display = "none";
      emperorScreen.style.display = "block";
    });

    /* ===========================================================
       â†“â†“â†“ EVERYTHING BELOW HERE IS YOUR ORIGINAL GAME LOGIC â†“â†“â†“
       (unchanged except removing leaderboard load on GameOver)
       =========================================================== */

    /* -- Existing game logic kept exactly as-is -- */

    /* ===================== Game Settings ===================== */
    const SIGMA_SCALE = 6;
    const STRETCH_MULT = 0.5;
    const WEIGHT_DECAY = 0.88;
    const WEIGHT_STRENGTH = 4;
    const START_STAGE = 8;
    const TIMER_SECONDS = 10;
    const DUPLICATE_PROTECTION = 25;
    const PENALTY_MULT = 2;

    /* ===================== State ===================== */
    let sessionId = buildSessionID(playerName);
    let stage = START_STAGE;
    let questionCount = 0;
    let correctCount = 0;
    let totalTimeTrue = 0;
    let penaltySeconds = 0;
    let productWeights = {};
    let recentAnswers = [];
    let current = null;
    let timeLeft = TIMER_SECONDS;
    let rafId = 0;
    let qStartTs = 0;
    let runStartTs = 0;
    let mistakesThisQuestion = 0;
    let loggedThisQuestion = false;

    let runData = { sessionID: "", results: [] };

    function buildSessionID(playerName) {
      const parts = (playerName || "Player").trim().split(/\s+/);
      const first = parts[0] || "Player";
      const last = parts[1] || "";

      // local MST formatting
      const now = new Date();
      const utc = now.getTime() + now.getTimezoneOffset()*60000;
      const mst = new Date(utc - 7*60*60000);

      const mm = String(mst.getMonth()+1).padStart(2,"0");
      const dd = String(mst.getDate()).padStart(2,"0");
      const yyyy = mst.getFullYear();
      const hh = String(mst.getHours()).padStart(2,"0");
      const min = String(mst.getMinutes()).padStart(2,"0");

      return `${first} ${last} ${mm}-${dd}-${yyyy} ${hh}:${min}`;
    }

    function resetRunState() {
      sessionId = buildSessionID(playerName);
      runData = { sessionID: sessionId, results: [] };

      stage = START_STAGE;
      questionCount = 0;
      correctCount = 0;
      totalTimeTrue = 0;
      penaltySeconds = 0;
      productWeights = {};
      recentAnswers = [];
      mistakesThisQuestion = 0;
      loggedThisQuestion = false;
      timeLeft = TIMER_SECONDS;
      cancelAnimationFrame(rafId);
    }

    function startGame(){
      resetRunState();
      runStartTs = performance.now();
      nextQuestion();
    }

    function randn(){
      let u=0,v=0;
      while(u===0)u=Math.random();
      while(v===0)v=Math.random();
      return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
    }

    function sampleTrunc(minV,maxV,mu,sigma){
      if(sigma<=0||!isFinite(sigma)) return Math.min(Math.max(mu,minV),maxV);
      for(let i=0;i<40;i++){
        const x=mu+sigma*randn();
        if(x>=minV && x<=maxV) return x;
      }
      return Math.min(Math.max(mu,minV),maxV);
    }

    function buildPairs(stage){
      const maxF = Math.floor(stage*(1+STRETCH_MULT));
      const out=[];
      for(let a=1;a<=maxF;a++){
        for(let b=1;b<=maxF;b++){
          if(a>stage && b>stage) continue;
          out.push([a,b]);
        }
      }
      return out;
    }

    function choosePair(pairs){
      let minP=Infinity,maxP=-Infinity;
      const prods=new Array(pairs.length);
      for(let i=0;i<pairs.length;i++){
        const p=pairs[i][0]*pairs[i][1];
        prods[i]=p;
        if(p<minP)minP=p;
        if(p>maxP)maxP=p;
      }
      const mu=(minP+maxP)/2;
      const sigma=Math.max(1e-6,(maxP-minP)/SIGMA_SCALE);
      const target=sampleTrunc(minP,maxP,mu,sigma);

      let bestIdx=-1,bestScore=Infinity,safety=0;
      while(safety++<500){
        for(let i=0;i<pairs.length;i++){
          const p=prods[i];
          if(recentAnswers.includes(p)) continue;
          const dist=Math.abs(p-target);
          const w=(productWeights[p]||0);
          const score = dist * (1 + WEIGHT_STRENGTH*w);
          if(score<bestScore){ bestScore=score; bestIdx=i; }
        }
        if(bestIdx!==-1) break;
        recentAnswers.shift();
      }
      const [a,b]=pairs[bestIdx];
      return {a,b,prod:a*b};
    }

    function decayWeightsAndBump(prod){
      for(const k in productWeights){
        productWeights[k]*=WEIGHT_DECAY;
        if(productWeights[k] < 1e-4) delete productWeights[k];
      }
      productWeights[prod]=(productWeights[prod]||0)+1;
    }

    function shake(el, mult=1){
      const urgency = 1 - (timeLeft/TIMER_SECONDS);
      const dur = 0.3 + 0.2*urgency;
      const base = 8;
      const mag = base * (1 + 2*urgency) * (1 + 0.3*(mult-1));
      const t0 = performance.now();
      (function step(){
        const dt = performance.now()-t0;
        if(dt < dur*1000){
          const k = 1 - dt/(dur*1000);
          const vertBias = 0.5 + 1.5*urgency;
          const dx=(Math.random()*2-1)*mag*k;
          const dy=(Math.random()*2-1)*mag*k*vertBias;
          el.style.transform=`translate(${dx}px,${dy}px)`;
          requestAnimationFrame(step);
        }else{
          el.style.transform='translate(0,0)';
        }
      })();
    }

    function nextQuestion(){
      const pairs = buildPairs(stage);
      let q; let guard=0;
      do{
        q = choosePair(pairs);
        guard++;
        if(guard>1000) break;
      }while(recentAnswers.includes(q.prod));

      recentAnswers.push(q.prod);
      if(recentAnswers.length > DUPLICATE_PROTECTION) recentAnswers.shift();

      current = q;
      mistakesThisQuestion = 0;
      loggedThisQuestion = false;

      document.getElementById("question").textContent =
        `${q.a} Ã— ${q.b}`;
      document.getElementById("answer").value = "";
      document.getElementById("answer").focus();
      document.getElementById("stage-info").textContent = `Stage ${stage}`;

      let penaltySecondsThisRound = 0;
      timeLeft = TIMER_SECONDS;
      qStartTs = performance.now();
      document.getElementById("timerFill").style.width = "100%";
      cancelAnimationFrame(rafId);

      const tick = () => {
        const elapsed = (performance.now() - qStartTs) / 1000;
        const remaining = TIMER_SECONDS - elapsed - penaltySecondsThisRound;
        timeLeft = Math.max(0, remaining);

        const pct = Math.max(0, Math.min(1, timeLeft / TIMER_SECONDS));
        document.getElementById("timerFill").style.width = (pct * 100) + "%";

        if (timeLeft <= 0) {
          const trueT = (performance.now() - qStartTs) / 1000;
          totalTimeTrue += trueT;
          runData.results.push({
            a: current.a,
            b: current.b,
            stage,
            timeTaken: trueT,
            mistakes: mistakesThisQuestion,
            success: false
          });
          return gameOver();
        }
        rafId = requestAnimationFrame(tick);
      };
      rafId = requestAnimationFrame(tick);

      document.getElementById("answer").oninput = (e)=>{
        if(!current) return;
        const val = e.target.value.trim();
        if(val === "") return;
        const correctStr = String(current.prod);

        if(val === correctStr){
          const trueT = (performance.now()-qStartTs)/1000;
          totalTimeTrue += trueT;
          correctCount++;
          questionCount++;
          runData.results.push({
            a: current.a,
            b: current.b,
            stage,
            timeTaken: trueT,
            mistakes: mistakesThisQuestion,
            success: true
          });

          decayWeightsAndBump(current.prod);

          const stepSize = 2*stage - 1;
          if(questionCount >= stepSize*(stage-START_STAGE+1)) stage++;

          current = null;
          return nextQuestion();
        }

        if(!correctStr.startsWith(val)){
          const avgModifiedSoFar =
            (totalTimeTrue + penaltySeconds) / Math.max(correctCount, 1) || 2.0;

          const penalty =
            avgModifiedSoFar * Math.pow(PENALTY_MULT, mistakesThisQuestion);

          mistakesThisQuestion++;
          penaltySeconds += penalty;
          penaltySecondsThisRound += penalty;

          const remaining =
            TIMER_SECONDS -
            ((performance.now() - qStartTs)/1000) -
            penaltySecondsThisRound;

          timeLeft = Math.max(0, remaining);

          const pct = Math.max(0, Math.min(1, timeLeft / TIMER_SECONDS));
          document.getElementById("timerFill").style.width = (pct * 100) + "%";

          e.target.value = val.slice(0, -1);
          shake(document.getElementById("question"), mistakesThisQuestion);

          if (remaining <= 0) {
            runData.results.push({
              a: current.a,
              b: current.b,
              stage,
              timeTaken: (performance.now() - qStartTs) / 1000,
              mistakes: mistakesThisQuestion,
              success: false
            });
            return gameOver();
          }
        }
      };
    }

    function gameOver(){
      cancelAnimationFrame(rafId);
      current = null;

      gameContainer.style.display = "none";
      endScreen.style.display = "block";

      document.getElementById("end-questions").textContent =
        `Questions answered: ${correctCount}`;
      document.getElementById("end-penalty").textContent =
        `Total penalty time: ${penaltySeconds.toFixed(2)} s`;

      const totalTrue = totalTimeTrue;
      const totalWithPen = totalTrue + penaltySeconds;

      document.getElementById("end-total").innerHTML =
        `Total time: ${totalTrue.toFixed(2)} s (` +
        `<span id="end-with-penalty">${totalWithPen.toFixed(2)}</span> s with penalties)`;

      const avgTrue = totalTrue / Math.max(correctCount,1);
      const avgPen = totalWithPen / Math.max(correctCount,1);

      document.getElementById("end-avg").innerHTML =
        `Avg time/question: ${avgTrue.toFixed(2)} s (` +
        `<span id="end-avg-with-penalty">${avgPen.toFixed(2)}</span> s with penalties)`;

      uploadSession(totalTrue);
    }

    async function uploadSession(totalTrue) {
      try {
        const payload = {
          sessionID: sessionId,
          playerName,
          stageReached: stage,
          totalTime: totalTrue,
          penaltyTime: penaltySeconds,
          questionsAnswered: correctCount,
          dateAdded: Date.now()
        };

        const answersArray = runData.results.map(q => ({
          a: q.a,
          b: q.b,
          stage: q.stage,
          timeTaken: q.timeTaken,
          mistakes: q.mistakes,
          success: q.success,
          dateAdded: Date.now()
        }));

        const sessionRef = doc(collection(db, "sessions"), sessionId);
        await setDoc(sessionRef, { ...payload, answers: answersArray });

        await addDoc(collection(db, "leaderboard"), payload);

        document.getElementById("saved-status").textContent = "Saved âœ“";

      } catch(e){
        document.getElementById("saved-status").textContent = "Upload failed";
      }
    }

  </script>
</body>
</html>
